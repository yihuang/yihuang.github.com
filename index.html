<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" contect="width=device-width"></meta>
        <meta name="KEYWords" contect="黃毅 yihuang codeplayer python haskell web"></meta>
        <link rel="alternate" type="application/rss+xml" title="blog post summary feeds" href="rss.xml" />
        <title>精确编程</title>
        <link rel="stylesheet" type="text/css" href="css/html4css1.css" />
        <link rel="stylesheet" type="text/css" href="css/blog.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="css/pygments.css"/>
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
    </head>
    <body>
	<div id="wrapper">
        <div id="header">
    <a href="index.html"><h1>精确编程</h1></a>
    <div class="nav-icons">
        <p class="nav">
            <a title="首页" href="index.html" class=""><img src="images/icons/home.png" alt="首页"/></a>
            <a title="文章列表" href="list.html" class=""><img src="images/icons/blog.png" alt="文章列表"/></a>
            <a title="订阅" href="rss.xml" class=""><img src="images/icons/about.png" alt="订阅"/></a>
        </p>
        <p class="link">
            <a title="Github" href="https://github.com/yihuang/" class=""><img src="images/icons/github.png" alt="Github"/></a>
            <a title="豆瓣" href="http://www.douban.com/people/huangyi/" class=""><img src="images/icons/douban.png" alt="豆瓣"/></a>
            <a title="新浪微博" href="http://weibo.com/1897911954" class=""><img src="images/icons/weibo.png" alt="新浪微博"/></a>
            <a title="Google Reader Share" href="http://www.google.com/reader/shared/yi.codeplayer" class=""><img src="images/icons/greader.png" alt="Google Reader Share"/></a>
            <a title="Delicious" href="http://www.delicious.com/huangyi" class=""><img src="images/icons/delicious.png" alt="Delicious"/></a>
            <a title="42区" href="http://42qu.com/-10000020" class=""><img src="images/icons/42qu.png" alt="42区"/></a>
            <a title="Blogger" href="http://codeplayer.blogspot.com/" class=""><img src="images/icons/blogger.png" alt="Blogger"/></a>
            <a title="豆瓣9点" href="http://9.douban.com/subject/9361637/" class=""><img src="images/icons/douban-nine.png" alt="豆瓣9点"/></a>
            <a title="啄木鸟社区" href="http://wiki.woodpecker.org.cn/moin/HuangYi" class=""><img src="images/icons/woodpecker.png" alt="啄木鸟社区"/></a>
        </p>
    </div>
</div>


        <!--
        <div class="widget-wrapper">
            <div id="recentcomments" class="dsq-widget"><h3 class="dsq-widget-title">Recent Comments</h3><script type="text/javascript" src="http://yi-programmer.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script></div>
            <div id="popularthreads" class="dsq-widget"><h3 class="dsq-widget-title">Popular Threads</h3><script type="text/javascript" src="http://yi-programmer.disqus.com/popular_threads_widget.js?num_items=5"></script></div>
        </div>
        -->
        <div id="content">
            <div id="right">
                <div class="post">
                    <a href="2018-03-06_blockchain-fp.html"><h1>区块链与函数式编程 <span class="date">2018-03-06</span></h1></a>
                    <p>区块链是对软件正确性要求极高的领域。过去软件bug和安全漏洞带来的损失，一般就是停止维护，被拖库就已经是很重大的影响了。而区块链软件的漏洞被利用，那将是灾难性的，因为上面跑的都是真金白银。随着区块链技术对传统经济领域渗透的加深，这种风险将会大大提升。</p>
<p>传统软件工程只重视产品的快速上线快速迭代，从来没有把软件的正确性摆在一个优先级很高的位置，究其根本还是传统领域软件出bug带来的成本不高。</p>
<p>行业里其实已经有一些关键领域是对软件的正确性要求极高的，比如航天系统，金融领域一些核心系统等。1962年软件bug造成火箭偏航，损失1850万美元；1978年CAD软件bug造成体育竞技场倒塌，损失上亿美元；1985年放射机软件bug导致病人受到大量辐射，1987年金融交易软件bug导致美国股灾，等等。</p>
<p>这些问题促使人们去思考如何保证软件正确性，而这些年来业界针对这种对软件正确性要求高的领域，也确实发展了一套技术手段来支持，形式验证、类型系统、纯函数式编程等。这些方法对程序员要求更高，开发时间也更长，所以在大部分编程领域，这种方法显得不是那么经济，换句话说99%的程序员其实并不了解这个领域的技术。而现在传统程序员开始进入区块链软件的开发，如果不能在思维、流程、工具各方面作出相应调整的话，是很危险的事情。</p>
<p>但是真正的形式验证成本巨大，只好用来解决一些最核心的问题。而另一种同时兼顾实用性的方案是函数式编程（函数式编程这个词语这些年有些定义模糊，这里特指静态类型纯函数式语言，基本上就是ML一族的语言），而Haskell是其中的佼佼者，也是Cardano项目使用的开发语言。</p>
<p>Haskell是一门 <em>纯函数式</em> <em>静态类型</em> 惰性求值的语言，这里关键字有几个：</p>
<ul class="simple">
<li>纯函数式是说，函数除了将输入转换为输出以外，不能有其他副作用（比如执行IO操作、修改全局变量、或者发射个导弹啥的），并且对于相同的输入永远返回相同的输出。这意味着不存在变量的概念，数据结构也都是immutable的。显然这样的函数会有很多良好的性质：好测试, 线程安全, 代码可重用, 可读性强等等。另外这样的代码还有一个性质是可证明，因为你可以机械地把函数的调用替代成函数的实现，而不改变其语意，所以你可以形式地证明比如说两个函数等价。还有一些其他的好处，比如一些代码重构工具能够自动调整代码，编译器也可以更激进地对代码进行优化，因为可以他们能够确保对程序的语意没有影响。</li>
<li>静态类型系统，按照“柯里-霍华德同构”定理，类型对应于命题，而程序对应于证明。当我们把问题的模型编码成类型后，编译器通过类型检查可以保证程序的正确性。在实践中，类型是可以逐步细化的，越细化，能够通过编译的实现就越少，甚至可能细化到只剩下一个有意义的实现，这种情况下甚至可以通过工具实现自动生成实现代码。类型系统还带来其他一些便利的工具，比如hoogle，可以根据类型签名搜索现有库提供的函数实现。</li>
</ul>
<p>关于Haskell语言其实可以说的还有很多，未来会继续写一些具体的编程模式，尤其是与区块链相关的，以及它在Cardano项目中的具体实践，敬请期待。</p>

                </div>
                <div class="post">
                    <a href="2018-03-05_cardano_africa.html"><h1>ADA的非洲和发展中国家计划 <span class="date">2018-03-05</span></h1></a>
                    <div class="note">
<p class="first admonition-title">注解</p>
<p class="last">翻译自：<a class="reference external" href="https://iohk.io/blog/cardanos-goals-for-africa-and-the-developing-world">https://iohk.io/blog/cardanos-goals-for-africa-and-the-developing-world</a></p>
</div>
<p>伦敦经济学院与非洲有着悠久的历史。1895年，布尔战争爆发前四年，学校刚成立，就开始了关于一个时代的辩论。一些新独立的非洲国家的第一批领导人曾在这里学习，学校里渐进主义和反帝国主义的立场被看到，并且参与了反种族隔离运动。</p>
<p>有了这样的历史，Charles Hoskinson选在这所大学来介绍Cardano接下来的计划再适合不过，那就是让这项技术服务于发展中国家，从非洲开始。
该讲座由Cardano基金会和伦敦经济学院区块链协会组织，在学校的Saw Swee Hock中心举行，听众数量是预计的两倍。</p>
<p>在星期二晚上开门之前，已经有数百人排起了长队，大部分是二三十岁的年轻人。</p>
<p>面对拥挤的人群，Charles阐述了Cardano今年将在非洲展开的愿景。</p>
<p>“你必须去到你想要帮助的国家和当地的人交谈。要改变世界的唯一方法就是你必须去到那里。实际操作的人不会是你，必须由当地人自己来做。“</p>
<p>IOHK使用一套在过去一年中已经在雅典和巴巴多斯试验过的课程，给这个地区的人传授技能。我们向年轻的程序员培训Haskell编程语言，这也是Cardano项目开发所使用的语言。培训结束后，他们可以选择加入Cardano项目，或者把他们的技术用于发展当地的经济。作为该计划的一个样板，我们和西印度群岛大学联合举办了Haskell课程，这是这个国家第一次教授Haskell语言。
甚至连Haskell创始人之一Philip Wadler教授也加入进来了，他同时也在帮助开发Cardano项目。</p>
<p>“下一阶段可能会在埃塞俄比亚进行，我们已经在进行商谈，”查尔斯说。“你必须在这个国家内部建立这么一群人，他们有动力去改善自己的国家并且真正理解如何运用科技。”</p>
<p>同样重要的是与当地政府合作，探索合作的机会。探索Cardano项目的潜在落地应用，例如与土地登记，身份或投票相关的应用。</p>
<div class="center-figure figure align-center">
<img alt="images/charles1.jpg" src="images/charles1.jpg" />
<p class="caption">Charles Hoskinson与Michael Parsons</p>
<div class="legend">
Cardano基金会主席</div>
</div>
<p>在非洲落地区块链应用的关键在于试验项目的成功运行，这能展示区块链技术作为一种更便宜更高效解决方案的优越性。“试验项目可以展示为什么区块链方案更快更好。
可以展示这项技术是可行的，并且人们可以从中赚很多钱，然后大家会说'我也要来一套'，
竞争会推动更多人加入这波浪潮，其中甚至还会出现我们的区块链竞争对手，“Charles说。</p>
<p>他认为非洲会是一个很重要的区块链案例。区块链技术的巨大潜力可以帮助他们token化自然资源、劳动力和财产，从而解锁这些国家的财富。“token不光可以用来玩以太猫，也可以用来干些实实在在的事情，我们要来尝试一下。”</p>
<p>“如果你去计算一下这些国家被锁住的资产，有数万亿美元的规模。讽刺的是，这些地方其实有着巨大的潜在价值，只要能被开发出来，并且公平地分配给当地的人，贫困将会消失，这些地方会成为一些最富有的国家。”</p>
<p>Charles说，这不会很容易，但是区块链的应用是不可避免的。当地政客有可能需要经济上激励才会支持这项技术，可能要通过预挖矿的方式。还有其他需要跨越的障碍，例如非洲零散的网络覆盖，这会妨碍区块链系统的连接。为了解决这个问题，IOHK正在探索卫星覆盖的方案，估计成本在5千万至1亿美元之间。可信硬件也能提供第二种解决方案，可以通过蓝牙进行离线交易，并在恢复网络时注册到区块链中。</p>
<p>另一个障碍是要提供兑换当地货币的兑换点。为此，IOHK正在研究如何以可承受的成本安装ATM终端网络，并且能够离网(off grid)工作。最后，加密货币的长期目标是开发一种价值稳定的货币，它与美元等法币挂钩，为商业提供稳定性，并且抵御数字货币的价格波动。
Charles宣布，IOHK正在启动一项研究工作来探索价值稳定的货币。尽管“没有银弹”，但他承诺将在这个问题上进行一系列的实验。</p>
<p>“这就是Cardano为发展中国家所做的，”Charles说。“我们有义务去尝试和探索这种技术，并把它提供给尽量多的人。”</p>
<div class="center-figure figure align-center">
<img alt="images/charles2.jpg" src="images/charles2.jpg" />
<p class="caption">Charles Hoskinson在伦敦经济学院演讲</p>
</div>
<p>演讲过后进行了问答环节，问题很宽泛，从中国区块链的未来，到Cardano的交易费，以及建立受监管的加密货币业务。</p>
<p>观众有着不同的背景，从观看了大量项目视频的严肃的Cardano粉丝到好奇的加密货币爱好者。</p>
<p>蒂莫27岁，是伦敦摄政商学院萨尔茨堡的一名学生。一年多以来他都对加密货币很感兴趣，他说他看过Charles的Ted演讲，看过他的采访，然后买了Ada。“这个项目比其他项目更加实在，这一点从团队还有web展示以及Charles的许多访谈中可以看出。”</p>
<p>“自从互联网以来，区块链是最具革命性的技术，”他的朋友托马斯23岁，来自安特卫普，在去年一次和父亲三小时的聊天中第一次了解到加密货币。“这激发了我的兴趣，然后我遇到了Charles的视频，并发现他是一个很聪明的人。
我喜欢Cardano解决区块链当前问题所用的方法 - 它是学术性的，把大学里的人拉了进来，里面还有有一些客观的成果的。”</p>
<p>其他人想在那里了解更多关于加密货币的信息。Ana，24岁，是伦敦经济学院法学专业的一名研究生。她对编写智能合约方面的论文感兴趣，因为她认为区块链是法律中新兴的领域。“我想更多地了解区块链，”她说。“其中的法律方面非常有趣，有很多问题需要解决。例如，如果您没有法院或法官参与，自行执行的合同是否合法？”</p>
<p>未来会有更多有关IOHK和非洲战略的信息，并将由非洲业务总监John O'Connor提供。</p>

                </div>
                <div class="post">
                    <a href="2018-03-04_kaleidoscope.html"><h1>Kaleidoscope: 一个安全的密码学扑克协议 <span class="date">2018-03-04</span></h1></a>
                    <div class="note">
<p class="first admonition-title">注解</p>
<p class="last">翻译自 <a class="reference external" href="https://iohk.io/blog/kaleidoscope-a-cryptographic-protocol-for-securely-playing-poker">https://iohk.io/blog/kaleidoscope-a-cryptographic-protocol-for-securely-playing-poker</a></p>
</div>
<p>扑克是世界上最流行的游戏之一，在赌场和互联网上都很受欢迎。尤其2000年后在线扑克迎来一阵风潮，产生了一个上百亿美元的市场。
然而目前的在线游戏形式要求用户无条件地信任在线赌场提供商，赌场可以随意进行暗箱操作，就算赌场不想，也难保他的员工不会想要赚点快钱。这些在现实世界中都有先例。</p>
<p>使用密码学安全的扑克协议可以让你安全地进行线上扑克，不需要信任任何第三方。事实上这方面的研究在现代密码学早期的时候就已经开始。
就在著名的RSA公钥加密模式提出几年后，Shamir, Rivest和Adleman就提出了第一代这种协议，并引发后续许多的相关研究。
然而由于下列原因，这方面的应用一直没有落地：</p>
<ol class="arabic simple">
<li>安全：现有协议的安全性保证并不明确，很难搞清楚他们具体的安全等级和可靠性。</li>
<li>效率：大部分现有协议都使用开销大的密码学技术，导致过高的计算和通讯开销，进而导致游戏延迟大，玩起来太卡。</li>
<li>经济：尽管经典密码学技术能够保证游戏的公平性（也就是没有玩家可以作弊或者查看其他玩家的隐私数据），
但是目前的扑克协议还是无法保证赢家一定得到经济奖励。</li>
</ol>
<p>我们最近给金融密码学2018会议上提交了一篇论文，其中构建了叫Kaleidoscope的协议，
这是第一个能解决上面三个问题的密码学扑克协议。Kaleidoscope是第一个在扑克游戏通常需要的安全模型下被证明安全的协议，另外通过使用区块链技术，可以保证赢家得到奖励，并且作弊者收到经济上的惩罚。同时它还比以前那些不能证明安全性的方案更加高效。</p>
<p>设计Kaleidoscope的第一步，就是要形式化地定义扑克协议需要做到的安全保证。
因为这种形式定义目前还不存在，所以我们提供了“仿真”模型下首个针对扑克协议的安全性定义。
我们的安全性定义考虑到了扑克游戏的所有阶段。并且只要有一方是诚实的，这个安全模型就不会被打破。
在扑克游戏中，所有玩家联合起来针对一个玩家作弊的情况并不少见。</p>
<p>有了这个的形式化模型后，我们又进一步开发了一套能够实现这些安全保证的协议。
这套协议建立在最新的洗牌零知识证明上，并且做到了计算和通讯两方面最佳的效率。
事实上，我们随后的工作表明，Kaleidoscope在提供极高安全性保证的同时，
计算量比以前的协议少了三倍，通讯量少了八倍。</p>
<p>Kaleidoscope另一个重要特性是能够保证赢家收到奖励，同时作弊者得到惩罚并被踢出游戏。
大概流程是这样的：游戏开始前，玩家先要把用于下注的资金和一定量的押金打到一个智能合约里。
游戏结束后，智能合约会根据游戏结局分发下注资金并返还押金，
如果有玩家被发现作弊，他的押金会被分给正常游戏的人。
我们的协议把对智能合约通讯量和链上存储的需求降到了最低。</p>
<p>虽然Kaleidoscope协议成功地解决了以上扑克协议面临的三个问题，但它只能用来玩扑克游戏。
有些人错误地认为扑克协议一定可以用来玩各种牌类游戏，但其实这会导致一些严重的安全问题。
但是具体到我们这个协议，还是能够把它的安全性模型、协议和证明扩展到通用的牌类游戏。
在这个过程中，我们创建了Royale, 一种能够安全地玩各种牌类游戏的协议，并且和Kaleidoscope一样高效。
我们会在后续的视频和博客中继续描述Royale的特性。</p>

                </div>
                <div class="post">
                    <a href="2018-03-02_zero-coin.html"><h1>匿名区块链和零知识证明 <span class="date">2018-03-02</span></h1></a>
                    <p>比特币有隐私问题。比特币的匿名性只体现在地址没有关联真人身份，但是所有交易信息却是完全公开的。
一旦别人知道你的比特币地址（比如他给你转过帐），他就可以从链上查到你所有的交易历史和余额。
尽管比特币推荐每笔交易都使用新地址，并且HD钱包技术可以自动管理这些地址，不需要用户操心。但是通过观察交易的模式，还是很容易发现这些地址的许多关联。</p>
<p>类零币(zcoin, zcash等)就是尝试解决这个问题。</p>
<p>传统的解决方案是中心化的混币操作，比如充值给交易所，再从交易所提现，因为交易所有许多地址，充值和提现的操作使用的很可能是不同的地址，这使得两笔交易之间在地址上没有关联。如果在余额和操作时间上再做点处理，可以让两笔交易完全没有关联，也就达到了真正的匿名性。这个方法唯一的问题是依赖中心化的交易所。那我们现在要做的就是利用密码学工具在链上解决这个问题。</p>
<div class="center-figure figure align-center">
<img alt="images/coinmix.png" src="images/coinmix.png" />
<p class="caption">传统混币模式</p>
</div>
<p>类零币解决这个问题的思路大体上和混币类似：</p>
<ol class="arabic simple">
<li>先做一笔铸币交易(充值到零币)：消耗一定的比特币，产生一个零币。</li>
<li>再做一笔使用交易(从零币提现): 消耗一个零币，产生一定比特币到目标账户。</li>
</ol>
<div class="center-figure figure align-center">
<img alt="images/zerocoin.png" src="images/zerocoin.png" />
<p class="caption">零币模式</p>
</div>
<p>这里的关键就在于，从零币提现时你不需要指定具体是哪一个零币(否则就暴露隐私了)，你只需要证明这个零币在里面，没用过，并且你有权限使用。要实现这一点就涉及到所谓的零知识证明。</p>
<p>零知识证明顾名思义，就是在不泄漏具体信息的前提下，向别人证明你知道某个信息。举一个例子：</p>
<blockquote>
<p>战争中你被俘了，敌人拷问你情报。你是这么想的：如果我把情报都告诉他们，他们就会认为我没有价值了，就会杀了我省粮食，但如果我死活不说，他们也会认为我没有价值而杀了我。怎样才能做到既让他们确信我知道情报，但又一丁点情报也不泄露呢？</p>
<p>这的确是一个令人纠结的问题，但阿里巴巴想了一个好办法，当强盗向他拷问打开山洞石门的咒语时，他对强盗说：“你们离我一箭之地，用弓箭指着我，你们举起右手我就念咒语打开石门，举起左手我就念咒语关上石门，如果我做不到或逃跑，你们就用弓箭射死我。”</p>
<p>强盗们当然会同意，因为这个方案不仅对他们没有任何损失，而且还能帮助他们搞清楚阿里巴巴到底是否知道咒语这个问题。阿里巴巴也没损失，因为处于一箭之地的强盗听不到他念的咒语，不必担心泄露了秘密，而且他确信自己的咒语有效，也不会发生被射死的杯具。</p>
</blockquote>
<p>这种证明方式称为交互式的，因为证明方和验证方需要进行多次交互才能完成证明。但是在区块链上，我们要向所有矿工进行证明，只能使用非交互式的方式。也就是，我把证明内容提交给区块链网络后，矿工可以独立完成验证，不用再问我问题。显然，非交互式的零知识证明才是真正的黑科技。</p>
<p>和很多密码学工具一样，非交互式的零知识证明也依赖一些神奇的数学工具：</p>
<div class="note">
<p class="first admonition-title">注解</p>
<p>存在加密函数 <tt class="docutils literal">E(x)</tt> 使得：</p>
<ol class="last arabic simple">
<li>如果x, y不同，那E(x), E(y)也不同。</li>
<li>根据E(x)很难反推x的值。</li>
<li>根据E(x)和E(y)，可以计算一些表达式的加密值，比如E(x+y)</li>
</ol>
</div>
<p>前面两条性质是哈希函数就满足的，重要的是第三条，第三条意味着我们在不知道x和y的情况，可以验证相关多项式的加密值。</p>
<p>比如说我要想你证明，我知道两个数a, b 使得：3 * a + 4 * b = 100，我只需要告诉你 E(a) 和 E(b) ，你就可以验证 E(3 * a + 4 * b) 是否等于 E(100) 。</p>
<p>同时为了防止你结合 E(a), E(b) 的值，以及表达式自身的性质去成功反推a和b，我还可以生成一个随机数r。
因为 <tt class="docutils literal">3 * (a - r/3) + 4 * (b + r/4) = 100</tt> ，然后告诉你 E(a - r/3) 和 E(b + r/4)，你还是可以成功验证，但绝对无法反推a和b的值。
这就是叫做随机偏移。</p>
<p>现在我们再增加一条黑科技：</p>
<div class="note">
<p class="first admonition-title">注解</p>
<p class="last">无论多复杂的验证问题都可以最终简化为一个多项式验证问题！</p>
</div>
<p>比如这么一个多项式：</p>
<pre class="literal-block">
P(x) = a0 + a1 * x + a2 * x^2 + … + ad * x^d
</pre>
<p>多项式验证问题是说，我要向你证明我知道这个多项式的系数，并且这个多项式的值满足一个公开的性质。</p>
<p>一个方法是，你给我一个随机数r，我算一个P(r)给你，你验证它满足性质。
抛开交互的问题（后面会说），它还存在一个问题：因为性质的公开的，坏人可以根据你给的r，伪造一个能满足性质的值。</p>
<p>按照我们加密函数的性质，你可以发送 E(1), E(r), E(r^2) ... E(r^t) 给我，我就可以计算 E(P(r)) 的值，并且不暴露r。
同样还可以在这基础上加上随机偏移。</p>
<p>这样我们就成功验证了多项式上一个随机点满足要求，两个多项式刚好在这个点相交的概率是很低的，
不过为了加强安全性，你再多发一个随机数k给我，我给你计算一个 E(kP(r)) 给你，按照数学(Knowledge of Coefficient Assumption)的理论，
你可以认为我确实知道这个多项式的系数了。</p>
<p>最终流程就是：你发两组数给我：[E(1), E(s), E(s2), ..., E(sd)], [E(k), E(ks), E(ks2), ..., E(ksd)]，我计算 E(P(s)) 和 E(kP(s)) 给你，
你验证 E(P(s)) 满足性质，并且 E(kP(s)) 是正确的即可。</p>
<p>最后还有这个交互的问题需要解决，为了把算法变成非交互式的，我们可以重用你发送给我的这两串数字，我们在区块链初始的时候，举行一个神秘的&quot;仪式&quot;，
生成r和k，并且计算出这两串加密数字，随后把r和k分散成n份，存在这个世界不同角落里n个信任的人手上，确保没有人知道r和k的真实值。</p>
<p>了解了这些数学工具，剩下的细节可以直接去看论文了。</p>

                </div>
                <div class="post">
                    <a href="2012-05-10_typeclass.html"><h1>Typeclass语法糖 <span class="date">2012-05-10</span></h1></a>
                    <p>你想让你的代码具备更高的复用性，比如说你写了一个牛逼的排序函数 <tt class="docutils literal">sort</tt> ，你不希望它只能对整数或是字符串排序，你希望它能对所有类型排序，也就是：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</div></pre></div>
<p>但是你的排序函数并不是真的能对所有类型排序，被排序的类型至少要支持比较操作，于是我们改成这样：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="kr">data</span> <span class="kt">Ordering</span> <span class="ow">=</span> <span class="kt">GT</span> <span class="o">|</span> <span class="kt">EQ</span><span class="o">|</span> <span class="kt">LT</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">sort</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</div></pre></div>
<p>通过让使用者主动提供比较函数，我们的函数可以支持尽可能多的类型。</p>
<p>又假设你想写一个网络服务程序，你又不想依赖特定的传输协议，我们也可以用类似的做法，只不过刚才是一个函数，这次变成一组：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="kr">data</span> <span class="kt">Connection</span> <span class="ow">=</span> <span class="kt">Connection</span>
</div><div class="line" id="LC1">  <span class="p">{</span> <span class="n">recv</span>  <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">ByteString</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">send</span>  <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">close</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</div><div class="line" id="LC1">  <span class="p">}</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">service</span> <span class="ow">::</span> <span class="kt">Connection</span> <span class="ow">-&gt;</span> <span class="o">...</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</div></pre></div>
<p>而具体传输协议的实现大概就是这样：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="nf">tcpConn</span> <span class="ow">::</span> <span class="kt">Socket</span> <span class="ow">-&gt;</span> <span class="kt">Connection</span>
</div><div class="line" id="LC1"><span class="nf">tcpConn</span> <span class="n">sock</span> <span class="ow">=</span> <span class="kt">Connection</span>
</div><div class="line" id="LC1">  <span class="p">{</span> <span class="n">recv</span>  <span class="ow">=</span> <span class="kt">Sock</span><span class="o">.</span><span class="n">recv</span> <span class="n">sock</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">send</span>  <span class="ow">=</span> <span class="kt">Sock</span><span class="o">.</span><span class="n">send</span> <span class="n">sock</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">close</span> <span class="ow">=</span> <span class="kt">Sock</span><span class="o">.</span><span class="n">close</span> <span class="n">sock</span>
</div><div class="line" id="LC1">  <span class="p">}</span>
</div></pre></div>
<p>再举一个例子，你想写一个hash map，其中key需要满足两个条件，一个是可以被hash，一个是可以比较，按照上面的做法，我们可能会这么写：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="kr">data</span> <span class="kt">IsKey</span> <span class="n">key</span> <span class="ow">=</span> <span class="kt">IsKey</span> <span class="n">key</span>
</div><div class="line" id="LC1">  <span class="p">{</span> <span class="n">hash</span>    <span class="ow">::</span> <span class="n">key</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">compare</span> <span class="ow">::</span> <span class="n">key</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
</div><div class="line" id="LC1">  <span class="p">}</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">lookup</span> <span class="ow">::</span> <span class="kt">IsKey</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
</div><div class="line" id="LC1"><span class="nf">insert</span> <span class="ow">::</span> <span class="kt">IsKey</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span>
</div><div class="line" id="LC1"><span class="c1">-- 此处省略若干操作</span>
</div></pre></div>
<p>这里就存在一个问题，没有人阻止我们对同一个map，传入不同的函数实现，比如不同的哈希算法，不同的比较实现，这样我们的数据结构就悲剧了。</p>
<p>Haskell的typeclass语法糖本质上就是隐式传入的一组函数，只不过通过与类型系统的结合，可以保证同一个类型针对同一个接口只有一个实现，从而避免了上面这个问题。</p>
<p>比如hash map的例子，用typeclass写就是这样的：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="kr">class</span> <span class="kt">IsKey</span> <span class="n">a</span> <span class="kr">where</span>
</div><div class="line" id="LC1">    <span class="n">hash</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</div><div class="line" id="LC1">    <span class="n">compare</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">lookup</span> <span class="ow">::</span> <span class="kt">IsKey</span> <span class="n">k</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
</div><div class="line" id="LC1"><span class="nf">insert</span> <span class="ow">::</span> <span class="kt">IsKey</span> <span class="n">k</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span>
</div></pre></div>
<p>为了让typeclass更好复用，实际上是这样的：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="kr">class</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="kr">where</span>
</div><div class="line" id="LC1">    <span class="n">hash</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="kr">class</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="kr">where</span>
</div><div class="line" id="LC1">    <span class="n">compare</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">lookup</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">k</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
</div><div class="line" id="LC1"><span class="nf">insert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">k</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">HashMap</span> <span class="n">k</span> <span class="n">v</span>
</div></pre></div>
<p>不过，语法糖也并不总是比原始语法更好用，语法糖用得别扭的时候考虑一下更原始的方案，也许会有新思路。</p>

                </div>
                <p class="more"><a href="list.html">查看全部文章>></a></p>
            </div>
        </div>
        <hr>
        <p class="copyright">Website content copyright &copy; by 黄毅. All rights reserved. </p>

	</div>

        <div id="sidebar" style="margin-top:10px;">
        <!--<div id="popularthreads" class="dsq-widget"><h2 class="dsq-widget-title">Popular Threads</h2><script type="text/javascript" src="http://yi-programmer.disqus.com/popular_threads_widget.js?num_items=5"></script></div>-->

        <!--<a href="http://disqus.com/">Powered by Disqus</a>-->
        </div>

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try{
        var pageTracker = _gat._getTracker("UA-415070-6");
        pageTracker._trackPageview();
        } catch(err) {}
    </script>
    </body>
</html>
