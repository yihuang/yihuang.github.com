<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" contect="width=device-width"></meta>
        <meta name="KEYWords" contect="黃毅 yihuang codeplayer python haskell web"></meta>
        <link rel="alternate" type="application/rss+xml" title="blog post summary feeds" href="rss.xml" />
        <title>精确编程</title>
        <link rel="stylesheet" type="text/css" href="css/html4css1.css" />
        <link rel="stylesheet" type="text/css" href="css/blog.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="css/pygments.css"/>
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
    </head>
    <body>
	<div id="wrapper">
        <div id="header">
    <a href="index.html"><h1>精确编程</h1></a>
    <div class="nav-icons">
        <p class="nav">
            <a title="首页" href="index.html" class=""><img src="images/icons/home.png" alt="首页"/></a>
            <a title="文章列表" href="list.html" class=""><img src="images/icons/blog.png" alt="文章列表"/></a>
            <a title="订阅" href="rss.xml" class=""><img src="images/icons/about.png" alt="订阅"/></a>
        </p>
        <p class="link">
            <a title="Github" href="https://github.com/yihuang/" class=""><img src="images/icons/github.png" alt="Github"/></a>
            <a title="知乎" href="https://zhuanlan.zhihu.com/fp-blockchain" class=""><img src="images/icons/zhihu.ico" alt="知乎"/></a>
            <a title="豆瓣" href="http://www.douban.com/people/huangyi/" class=""><img src="images/icons/douban.png" alt="豆瓣"/></a>
            <a title="Blogger" href="http://codeplayer.blogspot.com/" class=""><img src="images/icons/blogger.png" alt="Blogger"/></a>
            <a title="啄木鸟社区" href="http://wiki.woodpecker.org.cn/moin/HuangYi" class=""><img src="images/icons/woodpecker.png" alt="啄木鸟社区"/></a>
        </p>
    </div>
</div>


        <!--
        <div class="widget-wrapper">
            <div id="recentcomments" class="dsq-widget"><h3 class="dsq-widget-title">Recent Comments</h3><script type="text/javascript" src="http://yi-programmer.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script></div>
            <div id="popularthreads" class="dsq-widget"><h3 class="dsq-widget-title">Popular Threads</h3><script type="text/javascript" src="http://yi-programmer.disqus.com/popular_threads_widget.js?num_items=5"></script></div>
        </div>
        -->
        <div id="content">
            <div id="right">
                <div class="post">
                    <a href="2018-08-02_cardano-delegation-incentive.html"><h1>Cardano的委托和奖励体系 <span class="date">2018-08-02</span></h1></a>
                    <p>区块链中除了共识算法以外最重要的可能就是经济系统了，经济系统的设计目的是在大家都追求利益最大化的前提下，让系统进入我们希望达到的目标均衡状态。
Cardano这方面的规则刚出草案，在正式发布之前都还有可能修改，我们可以先大体了解一下。</p>
<p>简单介绍一下Cardano的Ouroboros协议。首先这是一个PoS协议，每个人都可以运行一个核心节点(通俗的说就是矿工节点)，即可获得与自己持有份额等比例的出块奖励。</p>
<p>为了让普通用户不用那么麻烦去维护一个服务器节点，Ouroboros支持委托机制，不想自己维护节点的人可以把自己的份额委托给其他人。
委托是可选的，并且是递归的，也就是说你可以选择自己挖矿，也可以选择委托别人挖矿，如果别人委托给你了，你还可以继续委托给其他人（递归的最大深度会有限制）。
也就是所谓的 <a class="reference external" href="https://medium.com/organizer-sandbox/liquid-democracy-true-democracy-for-the-21st-century-7c66f5e53b6f">Liquid Democracy</a> 。
同时会要求交易所钱包使用不同的地址类型，禁止交易所使用用户的币参与挖矿。</p>
<p>总之，有这么几种角色：独立挖矿者、矿池主、代理给矿池挖矿的普通持币者。</p>
<p>作为一个去中心化自治系统，我们又不希望设置太多硬性规定，尽量只设定最基本的规则，其中一些参数可以交给市场去博弈出具体的值，而另外一些固定的参数也可以在未来的财政系统中由大家投票去决定。</p>
<p>另外，Ouroboros的委托是不需要冻结用户的币的（除了矿池主注册矿池的时候可以主动冻结一些币，后面会提到），系统会在每个epoch开始的时候计算整体份额比例，并在一个epoch过程中保持不变，但是币本身随时都可以自由交易，在目前的设定下一个epoch持续5天。</p>
<p>奖励规则的设计目的主要是为了：</p>
<ul>
<li><p class="first">安全性</p>
<p>没有绝对的安全性，最终系统的安全性取决于各个角色攻击协议需要付出的成本，比如PoW系统的攻击成本是51%的算力，PoS系统的理论攻击成本是51%的币，但是因为有了委托的存在，矿池主用来出块的币实际上大于他本身持有的币，那么这种情况安全性上受到多大影响，是需要计算的。</p>
</li>
<li><p class="first">去中心化程度和稳定性的权衡</p>
<p>任何一个去中心化网络要保持稳定高效的运行，需要有稳定高效的矿工节点协同工作。作为一个去中心化系统，我们希望通过规则的设置让系统能够自动达到我们希望的稳定状态。</p>
</li>
</ul>
<p>我们先来看看其中涉及到的几个关键参数：</p>
<ul>
<li><p class="first">k</p>
<p>系统希望的均衡状态下矿池数量，默认值100。</p>
</li>
<li><p class="first">cost/margin</p>
<p>矿池运行需要的成本和利润抽成，矿池主的奖励计算大致逻辑是 <tt class="docutils literal">cost + margin * reward</tt> ，</p>
<p>如果margin为0，矿池主只拿cost数量的固定奖励，如果margin为1，矿池主拿走全部奖励。这个由矿池主注册矿池的时候设定，大家可以根据矿池主的设定选择代理给合适的矿池。</p>
</li>
<li><p class="first">s</p>
<p>矿池主注册矿池的时候主动选择冻结的币的比例，冻结越多，矿池整体奖励越高。</p>
</li>
<li><p class="first">σ</p>
<p>矿池整体拥有的stake比例。</p>
</li>
<li><p class="first">a0</p>
<p>这个系数是控制矿池主冻结份额数量对矿池整体奖励的影响程度，a0越小，影响程度越低。</p>
</li>
<li><p class="first">γ</p>
<p>如果矿池错过了出块，奖励会有减少，这个系数控制具体的减少程度。多出来的奖励并不会分给其他节点，而是全部进入财政系统。这样可以降低矿池之间彼此攻击的动机。</p>
</li>
</ul>
<p>其实从定性的角度大体上就清楚了，具体的定量分析大家可以期待Dr. Wang的分析结果，我这里就截个图大家自己看公式把：</p>
<div class="figure align-right">
<img alt="images/pool_reward.jpg" src="images/pool_reward.jpg" style="width: 100%;" />
<p class="caption">一个矿池在一个epoch中的奖励上限：</p>
</div>
<div class="figure align-right">
<img alt="images/pool_reward1.jpg" src="images/pool_reward1.jpg" style="width: 100%;" />
<p class="caption">考虑进矿池少出块的惩罚</p>
</div>

                </div>
                <div class="post">
                    <a href="2018-07-27_blockchain-network-architecture.html"><h1>轻量级连接 - 区块链的网络层设计 <span class="date">2018-07-27</span></h1></a>
                    <p>区块链是一种比较复杂的P2P软件，P2P软件本身也是网络编程中较为复杂的一种，网络编程本身也比传统编程更复杂一点。网络编程的复杂性来自于节点的状态，以及节点之间关系带来的状态空间的爆炸。P2P模糊了客户端服务器角色的界限，而区块链在普通P2P软件基础上则增加了大量的协议。归根结底，复杂性就是来源于状态空间规模的巨大增长。</p>
<p>节点需要保存的状态可以分为本地状态和远程状态，本地状态就是节点自身的数据，通常需要进行持久化保存，远程状态是用来记录一条连接的远端节点的状态，并由网络消息驱动状态的变迁，通常其生命周期和这条连接本身的生命周期绑定。</p>
<p>传统网络编程虽然节点之间关系简单，但使用事件驱动的方式编程的话，也会发现状态空间组合起来还是很头疼的。
这也是为什么微线程技术会成为网络编程的神器，因为线程的模型大大简化了状态之间潜在的组合关系。</p>
<p>用过微线程的朋友会发现，微线程简化了节点的状态组合，代价其实是对连接资源的独占，多条微线程想公用同一个连接的话，往往很容易会回到事件驱动编程的老路上去。</p>
<p>偏偏区块链的项目往往要在节点之间运行多套协议，常见的比如：节点发现、共识算法、区块同步、投票等等，未来专用或通用的MPC模型可能也是一个发展方向，除了节点发现往往会单独开一个UDP的端口以外，其他协议都是跑在一个TCP端口下。
这么复杂的协议如果要用微线程模型来开发的话，每套协议都得要一条甚至多条连接才能来搭配对应的微线程逻辑。然而就像原生线程一样，TCP连接也是成本高昂。</p>
<p>那么很自然的，轻量级连接的概念就可以提出来了。在一条TCP连接上多播大量的轻量级连接，是今天要介绍的重点。轻量级线程要配合轻量级连接才能发挥它完全的潜力。
据我所知，这个模式已经在一些项目中应用了，包括 <a class="reference external" href="https://whycardano.com/">Cardano</a> 、 <a class="reference external" href="https://github.com/libp2p">libp2p</a> 。</p>
<p>Cardano的实现是基于Haskell的 <a class="reference external" href="https://github.com/haskell-distributed/network-transport-tcp">network-transport</a> 库，
有兴趣的可以看看 <a class="reference external" href="http://haskell-distributed.github.io/tutorials/tutorial-NT2.html">教程</a> 。</p>

                </div>
                <div class="post">
                    <a href="2018-06-07_semi-formal-development.html"><h1>Cardano中的半形式化开发方法 <span class="date">2018-06-07</span></h1></a>
                    <p>翻译自：<a class="reference external" href="https://iohk.io/blog/semi-formal-development-the-cardano-wallet/">https://iohk.io/blog/semi-formal-development-the-cardano-wallet/</a></p>
<div class="note">
<p class="first admonition-title">注解</p>
<p class="last">把形式化的建模和QuickCheck的测试结合在一起，是开发高可信软件的一把利刃。
通过对不变量的测试来保证模型的一致性，通过和模型的比对来保证真实实现的正确性。</p>
</div>
<p>Well-Typed给IOHK做的咨询工作的一部分，就是和他们一起设计和开发Cardano虚拟货币钱包软件的全新版本。其中一个重要部分就是输出了一份关于钱包的 <a class="reference external" href="https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf">半形式化规范</a> ，
也就是一个描述钱包运行机制的数学模型以及相关的不变量和定理。</p>
<p>我们把它叫做“半形式化”是因为，虽然它描述了很多钱包的属性，也证明了其中一部分，但并没有证明其所有属性。
不过，就像我们后面会讲到的，我们可以使用 <a class="reference external" href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> （译注：一个能自动生成测试数据对属性进行测试的工具）
通过生成反例的方式来测试这些属性。
它不仅能帮助我们开发形式规范本身。如果未来我们真的证明了所有属性的正确性，它也为我们测试真实实现提供重要指导。</p>
<p>本文将向大家介绍这份形式规范，以及它是如何驱动新版本钱包的开发和测试的。
我们会展示了这个形式化开发方法的一部分，让大家大致了解它是什么样的，但不会涉及太多细节。
本文的目的是向大家介绍这套开发方法及其优势, 而不是具体的数学理论。</p>
<div class="note">
<p class="first admonition-title">注解</p>
<p class="last">本文所有图表、不变量、章节编号都来自于 <a class="reference external" href="https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf">1.1版本的规范</a></p>
</div>
<div class="section" id="utxo">
<h2>背景知识：UTxO记账法</h2>
<p>正常银行转账交易是从一个账户往另一个账户转移资产，比如张三给李四转账100元。
但是Cardano和比特币这种虚拟货币的交易略有不同。
交易的输出大体上差不多，唯一区别是可以有多个目标账号，比如一笔交易可以同时转70元给李四，30元给王五。
交易的输入就完全不同了，一笔交易的输入不是来自某个账户，而是来自其他交易。
举个例子，我们把这笔“给李四70元给王五30元”的交易叫做t1。</p>
<pre class="literal-block">
t1 输入: ...
   输出: 70元给李四, 30元给王五
</pre>
<p>现在如果李四想给赵六转50元，他可以创建一笔新交易说：用掉交易t1的第一个输出，然后给赵六50元，剩下20元给自己。</p>
<pre class="literal-block">
t2 输入: t1的第一个输出
   输出: 50元给赵六, 20元给李四
</pre>
<p>我们注意到李四需要把20元“找零”转回给自己，因为一个交易输出只能被使用(也就是用作另一笔交易的输入)一次。
这种风格的记账风格就叫做UTxO记账法。UTxO的意思就是未使用的交易输出。</p>
<p>而区块链就是许多这种交易组成的一个列表。对应的形式化定义差不多是这样的：</p>
<img alt="https://iohk.io/images/blog/utxo.png" src="https://iohk.io/images/blog/utxo.png" />
</div>
<div class="section" id="id3">
<h2>钱包</h2>
<p>虚拟货币的钱包就是一个软件工具，它会监控区块链的状态，跟踪用户的资金（准确的说就是用户的UTxO），也支持往区块链发送新的交易请求。
普通用户主要通过钱包和区块链打交道。至于验证新交易的有效性以及决定是否打包到区块中，这些不是钱包的任务，也就不在本文讨论的范围内了。</p>
<p>钱包的形式规范是一个数学抽象，它只关心钱包最核心的功能，忽略无关的细节。在Cardano钱包的基本模型中，我们把钱包状态简化到只包含UTxO以及在途交易(pending transactions)。
这份规范简单到用一张纸就可以写完：</p>
<img alt="https://iohk.io/images/blog/basicmodel.png" src="https://iohk.io/images/blog/basicmodel.png" />
<p>这个模型很简单，这样才方便进行更深入的研究，也方便提供相关属性的数学证明。
同时又足够精确，可以用来指导钱包的设计，也可以作为单元测试的基础，并驱动真实实现的开发。
他还可以用来研究可能存在的性能问题，以及如何来解决这些问题。</p>
</div>
<div class="section" id="id4">
<h2>余额</h2>
<p>钱包设计中有一些棘手的问题，余额的处理就是其中一个。
你可能觉得在钱包里展示余额应该是一件很简单的事情，但就算在传统银行账户中，也至少存在两种余额。比如张三给李四转100元之后，他的银行账户可能会说：</p>
<ul class="simple">
<li>你当前余额为1000元</li>
<li>有一笔100元的在途交易，所以你的可用余额为900元</li>
</ul>
<p>和传统银行交易不同，UTxO风格的交易多了一个找零的概念。
这就会产生三个余额的概念。我们还拿前面的t2交易为例，李四的钱包可能会这么汇报他的余额：</p>
<ul class="simple">
<li>你的可用UTxO为1070元</li>
<li>有一笔在途交易t2，所以你的可用余额为1000元</li>
<li>交易t2会转回20元，所以你的总余额其实是1020元</li>
</ul>
<p>注意到t2的找零只有当它被打包进区块链之后才可以使用。</p>
<p>目前为止，从钱包设计角度来看，问题还不算复杂，虽然用户界面的展示上可能还需要斟酌一下(要给用户展示哪个余额？)。真正的复杂性来自临时的区块分叉，也就是区块链上对于哪些交易需要被包含进来的分歧（分叉的产生以及如何解决不在本文探讨的范围）。</p>
<p>还是继续上面这个例子，假设t2在途，同时又出现了对t1的争议。争议解决后，钱包发现t1不在区块链中了（可能之后还会被重新包含进来）。
这个时候钱包的可用余额还是1000元，但是总余额如果还是1020元是否合理?
毕竟这样的话，总余额就大于可用UTxO了，倒不是说它一定不对，但总觉得不太舒服。</p>
<p>所以我们在形式规范中又定义了一个最小余额的概念：账户在各种可能出现的情况下，最小的那个余额。
在这个例子中，就是t1和t2都没有被打包进区块链的情况下，余额最小，为1000元
（注意不可能出现t2生效但t1不生效的情况，因为t2依赖t1）。
这个概念在直觉上似乎可行，但是为了让它更加精确并且可以计算，我们还需要引入另一个概念: ‘“预期UTxO”，也就是钱包期望包含进来但还没有被包含进来的UTxO。</p>
<img alt="https://iohk.io/images/blog/expectedutxo.png" src="https://iohk.io/images/blog/expectedutxo.png" />
<p>当然，就算不通过形式化的方法，我们也可以提出最小余额的概念，并且想出对应的算法。但是有这份形式规范可以让我们对这些问题研究地更加透彻，排除掉真实实现过程中周边的细节问题，专注于最核心的概念。</p>
</div>
<div class="section" id="id5">
<h2>内部一致性：不变量</h2>
<p>当我们引入一个像“预期UTxO”这样的新鲜概念的时候，我们怎么知道它是对的？
其实，既然新概念是我们自己定义的，再问它是否正确没有太大意义，我们应该问的是，它是否有用？</p>
<p>回答这个问题的一个办法就是找出不变量。不变量就是永远为真的属性。
比如上面展示的基本模型中就有这样一个不变量：</p>
<pre class="literal-block">
不变量3.4 txins pending ⊆ dom utxo
</pre>
<p>这个不变量是说，在途交易只能使用UTxO中的输出。这一点在直觉上貌似是显然的：钱包不能让用户使用它自己没有的资金。
然而，就像上面展示的，当我们开始考虑临时分叉的时候，这个不变量就不成立了。
李四提交的t2，使用了t1的一个输出，随后t1被回滚，这个时候他就使用了一个不在当前UTxO中的输出了。</p>
<p>这个时候我们又需要用上“预期UTxO”的概念了，在完整模型中，这个不变量需要改成这样：</p>
<pre class="literal-block">
不变量7.8 txins pending ⊆ dom (utxo expected)
</pre>
<p>换句话说，在途交易只能花费UTxO或者预期UTxO。</p>
<p>另一个不变量能够帮助我们巩固对“预期UTxO”这个概念的直觉理解：
一个输出不能既在UTxO中也在预期UTxO中。</p>
<blockquote>
不变量7.6 dom utxo 相交 dom expected = ∅</blockquote>
<p>毕竟如果一个预期UTxO出现在当前UTxO里的话就很奇怪了。
列出这样的不变量可以让我们对新概念的直觉理解变得精确，
而证明他们的正确性也能为形式规范的合理性以及内部一致性提供很强的保证。</p>
</div>
<div class="section" id="id6">
<h2>半形式化开发</h2>
<p>形式化地证明上面这样的不变量不光很耗时，还需要专业的数学训练。
如果能够证明他们当然是最完美的，但本文想说的是，尽管我们没有去证明，这个方法依然为我们提供巨大的帮助。
毕竟，我们之所以选择用Haskell编程，就是因为我们可以很容易地在Haskell代码和数学语言之间来回转换。</p>
<p>为了把形式规范中的钱包模型翻译成Haskell，我们使用一个在之前文章中介绍过的方法： <a class="reference external" href="http://www.well-typed.com/blog/2018/03/oop-in-haskell/">Haskell中的面向对象编程</a> (我们发明这个方法就是用来干这个的)。下面就是把基本模型翻译到Haskell代码的样子：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="nf">mkWallet</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hash</span> <span class="n">h</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Buildable</span> <span class="n">st</span><span class="p">)</span>
</div><div class="line" id="LC1">         <span class="ow">=&gt;</span> <span class="kt">Ours</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Lens&#39;</span> <span class="n">st</span> <span class="p">(</span><span class="kt">State</span> <span class="n">h</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">WalletConstr</span> <span class="n">h</span> <span class="n">a</span> <span class="n">st</span>
</div><div class="line" id="LC1"><span class="nf">mkWallet</span> <span class="n">ours</span> <span class="n">l</span> <span class="n">self</span> <span class="n">st</span> <span class="ow">=</span>
</div><div class="line" id="LC1">  <span class="p">(</span><span class="n">mkDefaultWallet</span> <span class="p">(</span><span class="n">l</span> <span class="o">.</span> <span class="n">statePending</span><span class="p">)</span> <span class="n">self</span> <span class="n">st</span><span class="p">)</span> <span class="p">{</span>
</div><div class="line" id="LC1">      <span class="n">utxo</span>       <span class="ow">=</span> <span class="n">st</span> <span class="o">^.</span> <span class="n">l</span> <span class="o">.</span> <span class="n">stateUtxo</span>
</div><div class="line" id="LC1">    <span class="p">,</span> <span class="n">ours</span>       <span class="ow">=</span> <span class="n">ours</span>
</div><div class="line" id="LC1">    <span class="p">,</span> <span class="n">applyBlock</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">self</span> <span class="p">(</span><span class="n">st</span> <span class="o">&amp;</span> <span class="n">l</span> <span class="o">%~</span> <span class="n">applyBlock&#39;</span> <span class="n">ours</span> <span class="n">b</span><span class="p">)</span>
</div><div class="line" id="LC1">    <span class="p">}</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">applyBlock&#39;</span> <span class="ow">::</span> <span class="kt">Hash</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1">            <span class="ow">=&gt;</span> <span class="kt">Ours</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Block</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1"><span class="nf">applyBlock&#39;</span> <span class="n">ours</span> <span class="n">b</span> <span class="kt">State</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">{</span>
</div><div class="line" id="LC1">    <span class="n">_stateUtxo</span>    <span class="ow">=</span> <span class="n">updateUtxo</span> <span class="n">ours</span> <span class="n">b</span> <span class="n">_stateUtxo</span>
</div><div class="line" id="LC1">  <span class="p">,</span> <span class="n">_statePending</span> <span class="ow">=</span> <span class="n">updatePending</span>   <span class="n">b</span> <span class="n">_statePending</span>
</div><div class="line" id="LC1">  <span class="p">}</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">updateUtxo</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">h</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Hash</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1">           <span class="ow">=&gt;</span> <span class="kt">Ours</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Block</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Utxo</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Utxo</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1"><span class="nf">updateUtxo</span> <span class="n">p</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">remSpent</span> <span class="o">.</span> <span class="n">addNew</span>
</div><div class="line" id="LC1">  <span class="kr">where</span>
</div><div class="line" id="LC1">    <span class="n">addNew</span><span class="p">,</span> <span class="n">remSpent</span> <span class="ow">::</span> <span class="kt">Utxo</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Utxo</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1">    <span class="n">addNew</span>   <span class="ow">=</span> <span class="n">utxoUnion</span> <span class="p">(</span><span class="n">utxoRestrictToOurs</span> <span class="n">p</span> <span class="p">(</span><span class="n">txOuts</span> <span class="n">b</span><span class="p">))</span>
</div><div class="line" id="LC1">    <span class="n">remSpent</span> <span class="ow">=</span> <span class="n">utxoRemoveInputs</span> <span class="p">(</span><span class="n">txIns</span> <span class="n">b</span><span class="p">)</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">updatePending</span> <span class="ow">::</span> <span class="kt">Hash</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1">              <span class="ow">=&gt;</span> <span class="kt">Block</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Pending</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Pending</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1"><span class="nf">updatePending</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="o">$</span> <span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">disjoint</span> <span class="p">(</span><span class="n">trIns</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">txIns</span> <span class="n">b</span><span class="p">)</span>
</div></pre></div>
<p>它比形式规范涉及到更多细节；比如它把具体的hash类型和地址类型抽象出去了。虽然它比规范稍微复杂一点，但也很接近了。
它依然是一个模型：没有处理任何网络或者存储方面的问题，可能也不是很高效，等等。也就是说，这个代码还不是真实钱包的设计。
但有这个模型还是有用的，两个原因，一个是我们可以用它来测试真实的钱包，我们会在下一节讨论这个话题；
另一个是我们可以用这个模型来测试不变量。比如下面的代码就是对上面提到的不变量7.8和7.6的Haskell翻译：</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="nf">pendingInUtxoOrExpected</span> <span class="ow">::</span> <span class="kt">WalletInv</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1"><span class="nf">pendingInUtxoOrExpected</span> <span class="n">l</span> <span class="n">e</span> <span class="ow">=</span>
</div><div class="line" id="LC1">  <span class="n">invariant</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;/pendingInUtxoOrExpected&quot;</span><span class="p">)</span> <span class="n">e</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
</div><div class="line" id="LC1">   <span class="n">checkSubsetOf</span>
</div><div class="line" id="LC1">    <span class="p">(</span><span class="s">&quot;txins pending&quot;</span><span class="p">,</span>
</div><div class="line" id="LC1">      <span class="n">txIns</span> <span class="p">(</span><span class="n">pending</span> <span class="n">w</span><span class="p">))</span>
</div><div class="line" id="LC1">    <span class="p">(</span><span class="s">&quot;utxo ∪ expected&quot;</span><span class="p">,</span>
</div><div class="line" id="LC1">      <span class="n">utxoDomain</span> <span class="p">(</span><span class="n">utxo</span> <span class="n">w</span><span class="p">)</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span><span class="p">`</span> <span class="n">utxoDomain</span> <span class="p">(</span><span class="n">expectedUtxo</span> <span class="n">w</span><span class="p">))</span>
</div><div class="line" id="LC1">
</div><div class="line" id="LC1"><span class="nf">utxoExpectedDisjoint</span> <span class="ow">::</span> <span class="kt">WalletInv</span> <span class="n">h</span> <span class="n">a</span>
</div><div class="line" id="LC1"><span class="nf">utxoExpectedDisjoint</span> <span class="n">l</span> <span class="n">e</span> <span class="ow">=</span>
</div><div class="line" id="LC1">  <span class="n">invariant</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;/utxoExpectedDisjoint&quot;</span><span class="p">)</span> <span class="n">e</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
</div><div class="line" id="LC1">   <span class="n">checkDisjoint</span>
</div><div class="line" id="LC1">    <span class="p">(</span><span class="s">&quot;dom utxo&quot;</span><span class="p">,</span>
</div><div class="line" id="LC1">      <span class="n">utxoDomain</span> <span class="p">(</span><span class="n">utxo</span> <span class="n">w</span><span class="p">))</span>
</div><div class="line" id="LC1">    <span class="p">(</span><span class="s">&quot;dom expected&quot;</span><span class="p">,</span>
</div><div class="line" id="LC1">      <span class="n">utxoDomain</span> <span class="p">(</span><span class="n">expectedUtxo</span> <span class="n">w</span><span class="p">))</span>
</div></pre></div>
<p>和刚才的钱包实现一样，Haskell代码比对应的形式规范涉及更多细节；比如上面这个代码和形式规范主要区别是可以在不变量不成立时提供详细的错误信息。除此之外，大体上还是对规范的直接翻译。</p>
<p>这样做的好处是，我们可以用QuickCheck来测试这些不变量。
我们为钱包生成随机(但有效)的事件（&quot;应用这个区块&quot;，&quot;提交这笔新交易&quot;，&quot;切换到另一个分叉&quot;），然后检查这些不变量在每一个时间点都成立。
比如规范发布第一个版本的时候就有一个低级错误：当钱包收到一个新区块时，它从预期UTxO里把该区块的输入移除了，而不是输出。一个很蠢的错误，但是如果人工审核的话很容易被忽视。
当然，证明的话可以发现这个问题，但是用QuickCheck也可以：</p>
<pre class="literal-block">
Wallet unit tests
  Test pure wallets
    Using Cardano model FAILED [1]

Failures:

  test/unit/Test/Spec/Models.hs:36:
  1) Wallet unit tests, Test pure wallets, Using Cardano model
       predicate failed on: Invalid [] InvariantViolation {
           name:     full/utxoExpectedDisjoint
         , evidence: NotSubsetOf {
                 dom utxo: ..
               , dom expected: ..
               , dom utxo `intersection` dom expected: ..
             }
         , events:   {
                 state: ..
               , action: ApplyBlock ..
               , state: ..
               , action: NewPending Transaction{ .. }
               , state: ..
               ..
               , action: Rollback
               ..
             }
         }
</pre>
<p>它不光告诉我们这个不变量不成立了；它还输出了能重现问题的事件序列以及相应的钱包状态（包括所有的中间状态），并且它还显示UTxO和预期UTxO的domain以及他们的交集是什么(他们的交集应该为空，却不为空)。</p>
</div>
<div class="section" id="id7">
<h2>测试真实的实现</h2>
<p>上面说到Haskell对钱包规范的翻译依然是一个模型，其中忽略了大量真实世界的复杂情况，而这些情况是完整的钱包实现必须处理的。
甚至模型中实现的数据类型也是真实版本的简化：交易中没有包含签名，区块只是一个交易列表而不是真实的区块等等。</p>
<p>尽管如此，我们还是可以用这个模型实现来测试真实实现。我们可以把简化版的类型转换到真实版本。既然我们已经有了针对简化类型的QuickCheck测试数据生成器，并且我们也已经能够对模型实现进行测试，我们就可以用下图的方式对真实实现进行测试：</p>
<img alt="https://iohk.io/images/blog/commute.png" src="https://iohk.io/images/blog/commute.png" />
<p>我们先用QuickCheck生成器生成简化模型的钱包事件，然后：</p>
<ol class="arabic simple">
<li>在简化类型的测试数据上执行模型实现，然后把结果翻译到真实实现</li>
<li>我们先把测试数据翻译到真实类型，然后执行真实钱包的实现</li>
</ol>
<p>我们可以比对两条执行路径的结果，如果相同的话，我们就可以认为真实钱包正确地实现了这个模型。
我们在每一步都去验证这一点，加上我们前面保证了模型实现中的不变量在每一步都成立，那么我们就能得出结论：不变量在真实实现中也在每一步都成立。</p>
<p>比如，如果真实钱包中有一个bug重复计算了在途交易的找零(比如一笔在途交易使用另一笔在途交易的找零作为输入，这只在分叉的情况下才会出现)，测试用例生成器就会找到一个反例，使得两条执行路径的结果不一致，并且告诉我们导致不一致的具体的钱包事件序列以及相应的钱包状态，以及不一致的具体值。</p>
</div>
<div class="section" id="id8">
<h2>结论</h2>
<p>软件的规范，就算存在，一般也都是些非形式化的文档，使用自然语言描述一下软件预期的功能。
这样的规范不能用来做校验，甚至对测试也用处不大。
另一方面，对所有属性都在数学上加以证明的完整的形式规范，成本很高也很耗时，而且需要相关领域的专家才能搞定。这种做的效果当然是最完美的，但是我们可以有这么一个折中的方案：形式化地描述模型及其属性，然后我们可以用QuickCheck对其属性进行测试。
另外，基于这个模型我们可以对核心功能进行分析，并最终和真实实现进行比对。</p>
<p>IOHK对新钱包的开发是开源的，相关代码可以在 <a class="reference external" href="https://github.com/input-output-hk/cardano-sl/tree/develop/wallet-new">Github</a> 上找到。
有趣的是，IOHK最近还招了人去实现Coq版本的钱包规范，这会把整个规范建立在更加坚实的基础之上。当然，这不代表目前的工作就没有意义，虽然这样的话，在模型实现中去测试不变量不再必要，但是有QuickCheck生成器去测试真实实现还是很有价值的。另外，在实际去证明不变量之前先用QuickCheck测试一遍，如果这个不变量确实不成立的话，可以帮助我们提早发现问题，从而节省宝贵的时间。</p>
</div>

                </div>
                <div class="post">
                    <a href="2018-05-30_run-ada-wallet.html"><h1>ADA币冲提接入教程 <span class="date">2018-05-30</span></h1></a>
                    <p>Cardano 1.2 版本支持了新的 <a class="reference external" href="https://cardanodocs.com/technical/wallet/api/v1/">钱包API</a> 。新的API设计很简洁，交易所或者其他应用想接入ADA币的冲提变得非常方便。
本教程教你如何从零开始实现ADA币的冲提功能。</p>
<div class="section" id="cardano">
<h2>编译运行Cardano钱包后端</h2>
<p>Windows和Mac系统，直接使用官方发布的钱包安装包即可。</p>
<p>Linux系统需要自己编译，编译过程如下：</p>
<ol class="arabic">
<li><p class="first"><a class="reference external" href="https://nixos.org/nix/download.html">安装nix</a> ，在非root账户下运行:</p>
<pre class="literal-block">
$ curl https://nixos.org/nix/install | sh
</pre>
<p>运行后会自动配置当前环境，重新登录当前终端即可生效。</p>
</li>
<li><p class="first">配置IOHK的Binary Cache：</p>
<pre class="literal-block">
$ sudo mkdir -p /etc/nix
$ sudo vi /etc/nix/nix.conf       # ..or any other editor, if you prefer
</pre>
<p>添加：</p>
<pre class="literal-block">
binary-caches            = https://cache.nixos.org https://hydra.iohk.io
binary-cache-public-keys = hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=
</pre>
</li>
<li><p class="first">取cardano源代码：</p>
<pre class="literal-block">
$ git clone https://github.com/input-output-hk/cardano-sl.git
$ cd cardano-sl
$ git checkout -b release/1.2.0 origin/release/1.2.0
</pre>
</li>
<li><p class="first">编译：</p>
<pre class="literal-block">
$ nix-env -A cardano-sl-wallet-new --install --file .
</pre>
<p>因为有Binary Cache，应该很快，成功后在目录 <tt class="docutils literal"><span class="pre">~/.nix-profile/bin/</span></tt> 中会多一个 <tt class="docutils literal"><span class="pre">cardano-node</span></tt> 的可执行文件，这个目录在安装nix的时候已经加入到 <tt class="docutils literal">PATH</tt> 了。</p>
</li>
<li><p class="first">另外整一个运行的目录，把相关配置拷贝过来：</p>
<pre class="literal-block">
$ mkdir ~/cardano-wallet
$ cd ~/cardano-wallet
$ mkdir lib
$ cp /path/to/cardano-sl/lib/{configuration.yaml,mainnet-genesis.json} lib
$ mkdir scripts
$ cp -r /path/to/cardano-sl/scripts/tls-files scripts/
</pre>
</li>
<li><p class="first">创建文件 <tt class="docutils literal"><span class="pre">wallet-topology.yaml</span></tt> ，内容如下：</p>
<pre class="literal-block">
wallet:
  fallbacks: 7
  valency: 1
  relays:
  - - host: relays.cardano-mainnet.iohk.io
</pre>
</li>
<li><p class="first">运行:</p>
<pre class="literal-block">
$ cardano-node --topology wallet-topology.yaml --configuration-key mainnet_wallet_linux64
</pre>
</li>
<li><p class="first">验证钱包V1 API工作正常：</p>
<pre class="literal-block">
$ curl --cacert scripts/tls-files/ca.crt https://localhost:8090/api/v1/node-info
{&quot;data&quot;:{&quot;syncProgress&quot;:{&quot;quantity&quot;:92,&quot;unit&quot;:&quot;percent&quot;},&quot;blockchainHeight&quot;:{&quot;quantity&quot;:1072633,&quot;unit&quot;:&quot;blocks&quot;},&quot;localBlockchainHeight&quot;:{&quot;quantity&quot;:996101,&quot;unit&quot;:&quot;blocks&quot;},&quot;localTimeInformation&quot;:{&quot;differenceFromNtpServer&quot;:{&quot;quantity&quot;:-147487,&quot;unit&quot;:&quot;microseconds&quot;}}},&quot;status&quot;:&quot;success&quot;,&quot;meta&quot;:{&quot;pagination&quot;:{&quot;totalPages&quot;:1,&quot;page&quot;:1,&quot;perPage&quot;:1,&quot;totalEntries&quot;:1}}}
</pre>
</li>
</ol>
</div>
<div class="section" id="v1-api">
<h2>使用V1 API实现冲提</h2>
<p>Cardano钱包API是符合swagger规范的，使用任何语言对swagger的封装即可使用，这里提供一个 <a class="reference external" href="https://gist.github.com/yihuang/d6fb374bb0786a0c64eb7a1d3cf1703e">使用python的pyswagger的示例</a> 。</p>
</div>

                </div>
                <div class="post">
                    <a href="2018-05-27_ouroboros-praos.html"><h1>Ouroboros Praos <span class="date">2018-05-27</span></h1></a>
                    <p><a class="reference external" href="https://iohk.io/research/papers/#XJ6MHFXX">Ouroboros Praos</a> 是IOHK发布的Ouroboros协议第二个版本。</p>
<div class="note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>第三个版本Genesis(已发布) 解决了PoS协议的Long Range Attack问题。</li>
<li>第四个版本Hydra(未发布) 将会解决分片问题。</li>
</ul>
</div>
<p>在 <a class="reference external" href="http://yi-programmer.com/2018-03-08_randomness-in-blockchain.html">区块链中的随机数</a>
一文中，我们介绍了第一个版本的Ouroboros PoS协议。我们看到随机数在slot leader选择中的重要作用，以及使用MPC生成安全可验证的随机数的方法。</p>
<p>但是原始 Ouroboros 协议存在这样一些问题：</p>
<ul class="simple">
<li>伪随机函数是公开的，也就是在epoch开始的时候，实际上恶意节点已经可以知道整个epoch中所有slot leader是谁了。恶意节点从而可以利用这一点进行攻击，比如贿赂和针对性的DDoS攻击。</li>
<li>MPC的性能是随着参与节点数量增加而降低的。</li>
<li>安全性论证基于对同步网络模型的假设。</li>
</ul>
<p>所以slot需要一定时长(20秒)确保诚实节点之间的同步。Praos的主要改进是采用可验证随机函数(VRF)代替公开伪随机函数进行slot leader选择。</p>
<div class="section" id="vrf">
<h2>可验证随机函数(VRF)</h2>
<p>可验证随机函数是一个密码学的工具，一种伪随机函数，可以使用私钥参与随机数的计算，同时别人可以使用公钥对计算结果进行验证。</p>
<div class="highlight None"><pre><div class="line" id="LC1"><span class="c1">-- 计算随机数</span>
</div><div class="line" id="LC1"><span class="nf">vrf</span> <span class="ow">::</span> <span class="kt">PrivateKey</span> <span class="ow">-&gt;</span> <span class="kt">Seed</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">VrfProof</span><span class="p">)</span>
</div><div class="line" id="LC1"><span class="c1">-- 验证随机数</span>
</div><div class="line" id="LC1"><span class="nf">verifyVrf</span> <span class="ow">::</span> <span class="kt">PublicKey</span> <span class="ow">-&gt;</span> <span class="kt">Seed</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">VrfProof</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</div><div class="line" id="LC1"><span class="c1">-- 区分不同slot</span>
</div><div class="line" id="LC1"><span class="nf">slotSeed</span> <span class="ow">::</span> <span class="kt">SlotIndex</span> <span class="ow">-&gt;</span> <span class="kt">EpochSeed</span> <span class="ow">-&gt;</span> <span class="kt">Seed</span>
</div></pre></div>
<p>使用这个工具，每个节点可以使用不同的伪随机函数判定自己是否是slot leader，具体方法是判定产生的随机数是否低于一个阀值，该阀值的值和节点stake比例相关。
如果是leader则直接出块，并在块中包含验证需要的proof信息。其他节点直到收到区块，才知道谁是slot leader。</p>
<p>因为每个节点随机函数是独立的，所以并不能像原始Ouroboros那样保证每个slot都刚好有且只有一个leader，可能没有人选中，也可能选中多个。不过praos新的安全性论证，已经考虑进这些情况，并且建立在半同步网络模型上，依然可以保证原来的安全属性。意味着praos的slot时长可以大大降低，也意味着这个版本性能将大大提升。</p>
<p>最后每个区块出块者会额外生成一个随机数放在区块中，用于产生下一个epoch的seed。</p>
</div>
<div class="section" id="key-evolving-signature-schemes">
<h2>Key Evolving Signature Schemes</h2>
<p>Praos引入KES解决另一个PoS的问题，就是恶意用户如果盗用了stake holder的私钥的情况，可以对它任意时刻出的块重新签名。</p>
<p>KES模式下，每次签名后都产生新的key，并抛弃旧的key。这样就算被黑掉当前的key，也无法伪造过去产生的区块签名。</p>
</div>

                </div>
                <p class="more"><a href="list.html">查看全部文章>></a></p>
            </div>
        </div>
        <hr>
        <p class="copyright">Website content copyright &copy; by 黄毅. All rights reserved. </p>

	</div>

        <div id="sidebar" style="margin-top:10px;">
        <!--<div id="popularthreads" class="dsq-widget"><h2 class="dsq-widget-title">Popular Threads</h2><script type="text/javascript" src="http://yi-programmer.disqus.com/popular_threads_widget.js?num_items=5"></script></div>-->

        <!--<a href="http://disqus.com/">Powered by Disqus</a>-->
        </div>

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try{
        var pageTracker = _gat._getTracker("UA-415070-6");
        pageTracker._trackPageview();
        } catch(err) {}
    </script>
    </body>
</html>
