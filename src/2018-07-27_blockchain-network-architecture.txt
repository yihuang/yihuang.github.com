===============================
轻量级连接 - 区块链的网络层设计
===============================

区块链是一种比较复杂的P2P软件，P2P软件本身也是网络编程中较为复杂的一种，网络编程本身也比传统编程更复杂一点。网络编程的复杂性来自于节点的状态，以及节点之间关系带来的状态空间的爆炸。P2P模糊了客户端服务器角色的界限，而区块链在普通P2P软件基础上则增加了大量的协议。归根结底，复杂性就是来源于状态空间规模的巨大增长。

节点需要保存的状态可以分为本地状态和远程状态，本地状态就是节点自身的数据，通常需要进行持久化保存，远程状态是用来记录一条连接的远端节点的状态，并由网络消息驱动状态的变迁，通常其生命周期和这条连接本身的生命周期绑定。

传统网络编程虽然节点之间关系简单，但使用事件驱动的方式编程的话，也会发现状态空间组合起来还是很头疼的。
这也是为什么微线程技术会成为网络编程的神器，因为线程的模型大大简化了状态之间潜在的组合关系。

用过微线程的朋友会发现，微线程简化了节点的状态组合，代价其实是对连接资源的独占，多条微线程想公用同一个连接的话，往往很容易会回到事件驱动编程的老路上去。

偏偏区块链的项目往往要在节点之间运行多套协议，常见的比如：节点发现、共识算法、区块同步、投票等等，未来专用或通用的MPC模型可能也是一个发展方向，除了节点发现往往会单独开一个UDP的端口以外，其他协议都是跑在一个TCP端口下。
这么复杂的协议如果要用微线程模型来开发的话，每套协议都得要一条甚至多条连接才能来搭配对应的微线程逻辑。然而就像原生线程一样，TCP连接也是成本高昂。

那么很自然的，轻量级连接的概念就可以提出来了。在一条TCP连接上多播大量的轻量级连接，是今天要介绍的重点。轻量级线程要配合轻量级连接才能发挥它完全的潜力。
据我所知，这个模式已经在一些项目中应用了，包括 `Cardano <https://whycardano.com/>`_ 、 `libp2p <https://github.com/libp2p>`_ 。

Cardano的实现是基于Haskell的 `network-transport <https://github.com/haskell-distributed/network-transport-tcp>`_ 库，
有兴趣的可以看看 `教程 <http://haskell-distributed.github.io/tutorials/tutorial-NT2.html>`_ 。
